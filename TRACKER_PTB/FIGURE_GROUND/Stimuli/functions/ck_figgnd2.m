function [stimulus, offscr] = ck_figgnd(Stm, screenNumber)
% ck_figgnd - create fig-gnd stimuli
% adapted for Tracker@NIN, C.Klink, Jan 2019

global Par
open_tex = []; % keep track of open textures and close them at the end

%% Draw texture in offscreen windows & make texture -----------------------
% create neutral background texture --
zoomfactor = 2.5;
[offscr.w, offscr.rect] = Screen('OpenOffscreenWindow', ...
    screenNumber, Stm.BackColor*Par.ScrWhite, ...
    zoomfactor*Par.wrect); %#ok<*SAGROW>
Screen('BlendFunction', offscr.w, ...
    GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
[offscr.center(1), offscr.center(2)] = RectCenter(offscr.rect);

%% Create empty background ------------------------------------------------
Screen('FillRect',offscr.w,Stm.BackColor*Par.ScrWhite);
temparray = Screen('GetImage',offscr.w);
stimulus.BG.array{1} = uint8(temparray);
BG.tex{1} = Screen('MakeTexture',Par.window,stimulus.BG.array{1});
            
%% Create textured background ---------------------------------------------
fprintf('Creating Ground-texture seeds...\n');
ScrSize = Par.wrect(3:4);
for gs = 1:Stm.Gnd_all.NumSeeds
    switch Stm.StimType{2}
        case 'lines'
            % Create lines --------------------------------------------
            Surf_tot = ScrSize(1)*ScrSize(2);
            Surf_line = Stm.Gnd_all.lines.length*Stm.Gnd_all.lines.width;
            Stm.Gnd_all.lines.n = round(...
                Stm.Gnd_all.lines.density*(Surf_tot/Surf_line));
            X1 = round(rand(round(Stm.Gnd_all.lines.n*(zoomfactor^2)),1).*...
                (zoomfactor*ScrSize(1)+...
                (Stm.Gnd_all.lines.length*zoomfactor))-...
                (offscr.center(1)+Stm.Gnd_all.lines.length));
            Y1 = round(rand(round(Stm.Gnd_all.lines.n*(zoomfactor^2)),1).*...
                (zoomfactor*ScrSize(2)+...
                (Stm.Gnd_all.lines.length*zoomfactor))-...
                (offscr.center(2)+Stm.Gnd_all.lines.length));
            X2 = round(X1 + Stm.Gnd_all.lines.length);
            Y2 = Y1; XY = [];
            for i=1:size(X1,1)
                XY = [XY [X1(i) X2(i); Y1(i) Y2(i)]]; %#ok<*AGROW>
            end
            
            % draw lines in offscreen window
            Screen('FillRect',offscr.w,Stm.Gnd_all.backcol*Par.ScrWhite)
            Screen('DrawLines', offscr.w, XY, Stm.Gnd_all.lines.width,...
                Stm.Gnd_all.lines.color*Par.ScrWhite, offscr.center,1);
            temparray = Screen('GetImage',offscr.w);
            stimulus.Gnd_all.array{gs,1} = uint8(temparray);
            
            if Stm.InvertPolarity
                % draw lines in offscreen window
                Screen('FillRect',...
                    offscr.w,Stm.Gnd_all.lines.color*Par.ScrWhite)
                Screen('DrawLines', offscr.w, XY, Stm.Gnd_all.lines.width,...
                    Stm.Gnd_all.backcol*Par.ScrWhite, offscr.center,1);
                temparray = Screen('GetImage',offscr.w);
                stimulus.Gnd_all.array{gs,2} = uint8(temparray);
            end
            
            % make textures >> we need it here for figure generation but we
            % cannot save them so the runstim needs to regenerate them.
            Gnd_all.tex{gs,1} = Screen('MakeTexture',Par.window,...
                stimulus.Gnd_all.array{gs,1});
            open_tex = [open_tex Gnd_all.tex{gs,1}];
            if Stm.InvertPolarity
                Gnd_all.tex{gs,2} = Screen('MakeTexture',Par.window,...
                    stimulus.Gnd_all.array{gs,2});
                open_tex = [open_tex Gnd_all.tex{gs,2}];
            end
            
        case 'dots'
            % Create dots ---------------------------------------------
            Surf_tot = ScrSize(1)*ScrSize(2);
            Surf_dot = Stm.Gnd_all.dots.size^2;
            Stm.Gnd_all.dots.n = round(...
                Stm.Gnd_all.dots.density*(Surf_tot/Surf_dot));
            X1 = round(...
                rand(round(Stm.Gnd_all.dots.n),1).*ScrSize(1));
            Y1 = round(...
                rand(round(Stm.Gnd_all.dots.n),1).*ScrSize(2));
            XY = [X1'; Y1'];
            
            % --- dot based ------
            stimulus.Gnd_all.dots.XY{gs,1}=XY;
            stimulus.Gnd_all.dots.color{gs,1}=...
                Stm.Gnd_all.dots.color*Par.ScrWhite;
            if Stm.InvertPolarity
                stimulus.Gnd_all.dots.XY{gs,2}=...
                    stimulus.Gnd_all.dots.XY{gs,1};
                stimulus.Gnd_all.dots.color{gs,2}=...
                    Stm.Gnd_all.backcol*Par.ScrWhite;
            end    
        case 'dots_tex'
            % create a fullscreen texture with 'dots' here
            % draw lines in offscreen window
            Screen('FillRect',offscr.w,Stm.Gnd_all.backcol*Par.ScrWhite)
            

            
            

            
            
            
            temparray = Screen('GetImage',offscr.w);
            stimulus.Gnd_all.array{gs,1} = uint8(temparray);
            
            if Stm.InvertPolarity
                % draw lines in offscreen window
                Screen('FillRect',...
                    offscr.w,Stm.Gnd_all.lines.color*Par.ScrWhite)
                Screen('DrawLines', offscr.w, XY, Stm.Gnd_all.lines.width,...
                    Stm.Gnd_all.backcol*Par.ScrWhite, offscr.center,1);
                temparray = Screen('GetImage',offscr.w);
                stimulus.Gnd_all.array{gs,2} = uint8(temparray);
            end
            
            % make textures >> we need it here for figure generation but we
            % cannot save them so the runstim needs to regenerate them.
            Gnd_all.tex{gs,1} = Screen('MakeTexture',Par.window,...
                stimulus.Gnd_all.array{gs,1});
            open_tex = [open_tex Gnd_all.tex{gs,1}];
            if Stm.InvertPolarity
                Gnd_all.tex{gs,2} = Screen('MakeTexture',Par.window,...
                    stimulus.Gnd_all.array{gs,2});
                open_tex = [open_tex Gnd_all.tex{gs,2}];
            end


    end
end

%% Create figure rects and textures ---------------------------------------
fprintf('Creating Figure-texture seeds...\n');
for f = 1:length(Stm.Fig) 
    FigSize = round(Stm.Fig(f).size*Par.PixPerDeg);
    FigPos = round(Stm.Fig(f).position*Par.PixPerDeg);
    FigCenter = [Par.ScrCenter(1)+FigPos(1) ...
        Par.ScrCenter(2)+FigPos(2)];
    stimulus.Fig(f).RectDest = round([FigCenter(1)-FigSize(1)/2 ...
        FigCenter(2)-FigSize(2)/2 ...
        FigCenter(1)+FigSize(1)/2 ...
        FigCenter(2)+FigSize(2)/2 ]);
    stimulus.Fig(f).RectSrc = round([offscr.center(1)-FigSize(1)/2 ...
        offscr.center(2)-FigSize(2)/2 ...
        offscr.center(1)+FigSize(1)/2 ...
        offscr.center(2)+FigSize(2)/2 ]);
    
    %fprintf([Stm.Fig(f).shape '\n']);
    if strcmp(Stm.Fig(f).shape,'Triangle_up')
        Stm.Fig(f).Triangle = round([...
            offscr.center(1) offscr.center(2)-sqrt(FigSize(1)^2-(FigSize(1)/2)^2)/2 ;...
            offscr.center(1)+FigSize(1)/2 offscr.center(2)+sqrt(FigSize(1)^2-(FigSize(1)/2)^2)/2 ;...
            offscr.center(1)-FigSize(1)/2 offscr.center(2)+sqrt(FigSize(1)^2-(FigSize(1)/2)^2)/2 ;...
            offscr.center(1) offscr.center(2)-sqrt(FigSize(1)^2-(FigSize(1)/2)^2)/2]);
    elseif strcmp(Stm.Fig(f).shape,'Triangle_down')
        Stm.Fig(f).Triangle = round([...
            offscr.center(1)-FigSize(1)/2 offscr.center(2)-sqrt(FigSize(1)^2-(FigSize(1)/2)^2)/2 ;...
            offscr.center(1)+FigSize(1)/2 offscr.center(2)-sqrt(FigSize(1)^2-(FigSize(1)/2)^2)/2 ;...
            offscr.center(1) offscr.center(2)+sqrt(FigSize(1)^2-(FigSize(1)/2)^2)/2 ;...
            offscr.center(1)-FigSize(1)/2 offscr.center(2)-sqrt(FigSize(1)^2-(FigSize(1)/2)^2)/2]);
    elseif strcmp(Stm.Fig(f).shape,'U')
        GapSize = round(Stm.Fig(f).NU_gapsize*Par.PixPerDeg);
        Stm.Fig(f).U = round([...
            offscr.center(1)-FigSize(1)/2 offscr.center(2)-FigSize(2)/2 ; ...
            offscr.center(1)-GapSize(1)/2 offscr.center(2)-FigSize(2)/2 ; ...
            offscr.center(1)-GapSize(1)/2 offscr.center(2)-FigSize(2)/2+GapSize(2) ; ...
            offscr.center(1)+GapSize(1)/2 offscr.center(2)-FigSize(2)/2+GapSize(2) ; ...
            offscr.center(1)+GapSize(1)/2 offscr.center(2)-FigSize(2)/2 ; ...
            offscr.center(1)+FigSize(1)/2 offscr.center(2)-FigSize(2)/2 ; ...
            offscr.center(1)+FigSize(1)/2 offscr.center(2)+FigSize(2)/2 ; ...
            offscr.center(1)-FigSize(1)/2 offscr.center(2)+FigSize(2)/2 ; ...
            offscr.center(1)-FigSize(1)/2 offscr.center(2)-FigSize(2)/2 ; ...
            ]);
    elseif strcmp(Stm.Fig(f).shape,'N')
        GapSize = round(Stm.Fig(f).NU_gapsize*Par.PixPerDeg);
        Stm.Fig(f).N = round([...
            offscr.center(1)-FigSize(1)/2 offscr.center(2)-FigSize(2)/2 ; ...
            offscr.center(1)+FigSize(1)/2 offscr.center(2)-FigSize(2)/2 ; ...
            offscr.center(1)+FigSize(1)/2 offscr.center(2)+FigSize(2)/2 ; ...
            offscr.center(1)+GapSize(1)/2 offscr.center(2)+FigSize(2)/2 ; ...
            offscr.center(1)+GapSize(1)/2 offscr.center(2)+FigSize(2)/2-GapSize(2) ; ...
            offscr.center(1)-GapSize(1)/2 offscr.center(2)+FigSize(2)/2-GapSize(2) ; ...
            offscr.center(1)-GapSize(1)/2 offscr.center(2)+FigSize(2)/2 ; ...
            offscr.center(1)-FigSize(1)/2 offscr.center(2)+FigSize(2)/2 ; ...
            offscr.center(1)-FigSize(1)/2 offscr.center(2)-FigSize(2)/2 ; ...
            ]);        
    end
    stimulus.Fig(f).ori_ind = Stm.Fig(f).ori_ind;
    
    switch Stm.StimType{2}
        case 'lines' | 'dots_tex'
            Screen('FillRect',offscr.w,0)
            if strcmp(Stm.Fig(f).shape,'Triangle_up') || ...
                    strcmp(Stm.Fig(f).shape,'Triangle_down')
                Screen('FillPoly',offscr.w,[],Stm.Fig(f).Triangle,1)
            elseif strcmp(Stm.Fig(f).shape,'N')
                Screen('FillPoly',offscr.w,[],Stm.Fig(f).N)
            elseif strcmp(Stm.Fig(f).shape,'U')
                Screen('FillPoly',offscr.w,[],Stm.Fig(f).U)
            elseif strcmp(Stm.Fig(f).shape,'Oval')
                Screen('FillOval',offscr.w,[],stimulus.Fig(f).RectSrc)
            elseif strcmp(Stm.Fig(f).shape,'Rectangle')
                Screen('FillRect',offscr.w,[],stimulus.Fig(f).RectSrc,1)
            end
            temparray = Screen('GetImage',offscr.w);
            stimulus.Fig(f).figmask = uint8(temparray(:,:,1));
            
        case 'dots'
            % --- dots based -------
            stimulus.Fig(f).figmask.type = Stm.Fig(f).shape;
            for gs = 1:Stm.Gnd_all.NumSeeds
                stimulus.Fig(f).dots.XY{gs,1} = stimulus.Gnd_all.dots.XY{gs,1};
                stimulus.Fig(f).dots.color{gs,1} = stimulus.Gnd_all.dots.color{gs,1};
                if Stm.InvertPolarity
                    stimulus.Fig(f).dots.XY{gs,2}=...
                        stimulus.Fig(f).dots.XY{gs,1};
                    stimulus.Fig(f).dots.color{gs,2}=...
                        Stm.Gnd_all.backcol*Par.ScrWhite;
                end
            end  
            
            switch Stm.Fig(f).shape
                case 'N'
                    FigGap = round(Stm.Fig(f).NU_gapsize*Par.PixPerDeg);
                    legwidth = (FigSize(1)-FigGap(1))./2; 
                    bridgewidth = FigSize(2)-FigGap(2); 
                    stimulus.Fig(f).figmask.vert = round( ...
                        [FigCenter(2)-(FigSize(2)/2) ...
                        FigCenter(2)+(FigSize(2)/2)]);
                    stimulus.Fig(f).figmask.hor = round( ...
                        [FigCenter(1)-(FigSize(1)/2) ...
                        FigCenter(1)+(FigSize(1)/2)]);
                    stimulus.Fig(f).figmask.lx = ...
                        [stimulus.Fig(f).figmask.hor(1) ...
                        stimulus.Fig(f).figmask.hor(1)+legwidth];
                    stimulus.Fig(f).figmask.rx = ...
                        [stimulus.Fig(f).figmask.hor(2)-legwidth ...
                        stimulus.Fig(f).figmask.hor(2)];
                    stimulus.Fig(f).figmask.bridge = ...
                        [stimulus.Fig(f).figmask.vert(1) ...
                        stimulus.Fig(f).figmask.vert(1)+bridgewidth];
                case 'U'
                    FigGap = round(Stm.Fig(f).NU_gapsize*Par.PixPerDeg);
                    legwidth = (FigSize(1)-FigGap(1))./2; 
                    bridgewidth = FigSize(2)-FigGap(2); 
                    stimulus.Fig(f).figmask.vert = round( ...
                        [FigCenter(2)-(FigSize(2)/2) ...
                        FigCenter(2)+(FigSize(2)/2)]);
                    stimulus.Fig(f).figmask.hor = round( ...
                        [FigCenter(1)-(FigSize(1)/2) ...
                        FigCenter(1)+(FigSize(1)/2)]);
                    stimulus.Fig(f).figmask.lx = ...
                        [stimulus.Fig(f).figmask.hor(1) ...
                        stimulus.Fig(f).figmask.hor(1)+legwidth];
                    stimulus.Fig(f).figmask.rx = ...
                        [stimulus.Fig(f).figmask.hor(2)-legwidth ...
                        stimulus.Fig(f).figmask.hor(2)];
                    stimulus.Fig(f).figmask.bridge = ...
                        [stimulus.Fig(f).figmask.vert(2)-bridgewidth ...
                        stimulus.Fig(f).figmask.vert(2)];
                case 'Oval'
                    stimulus.Fig(f).figmask.vert = round( ...
                        [FigCenter(2)-(FigSize(2)/2) ...
                        FigCenter(2)+(FigSize(2)/2)]);
                    stimulus.Fig(f).figmask.hor = round( ...
                        [FigCenter(1)-(FigSize(1)/2) ...
                        FigCenter(1)+(FigSize(1)/2)]);
                    stimulus.Fig(f).figmask.center = [....
                        mean(stimulus.Fig(f).figmask.hor) ...
                        mean(stimulus.Fig(f).figmask.vert)];
                    stimulus.Fig(f).figmask.r = [ ...
                        diff(stimulus.Fig(f).figmask.hor)/2 ...
                        diff(stimulus.Fig(f).figmask.vert)/2 ];
                case 'Rectangle'
                    stimulus.Fig(f).figmask.vert = round( ...
                        [FigCenter(2)-(FigSize(2)/2) ...
                        FigCenter(2)+(FigSize(2)/2)]);
                    stimulus.Fig(f).figmask.hor = round( ...
                        [FigCenter(1)-(FigSize(1)/2) ...
                        FigCenter(1)+(FigSize(1)/2)]);
            end
    end
end

switch Stm.StimType{2}
    case 'lines'
        for ori = 1:length(Stm.Fig_all.orientations)
            for fs=1:Stm.Gnd_all.NumSeeds
                for p = 1:size(Gnd_all.tex,2)
                    % textured figure basis
                    Screen('DrawTexture',offscr.w,...
                        Gnd_all.tex{fs,p},[],[],Stm.Fig_all.orientations(ori));
                    array = Screen('GetImage',offscr.w);
                    stimulus.Fig_all.array{fs,p,ori} = uint8(array);
                end
            end
        end
    case 'dots'
        % do nothing
    case 'dots_tex'
        for fs=1:Stm.Gnd_all.NumSeeds
            for p = 1:size(Gnd_all.tex,2)
                % textured figure basis
                Screen('DrawTexture',offscr.w,...
                    Gnd_all.tex{fs,p},[],[]);
                array = Screen('GetImage',offscr.w);
                stimulus.Fig_all.array{fs,p} = uint8(array);
            end
        end
end

%% Close the created textures
Screen('Close',open_tex);
